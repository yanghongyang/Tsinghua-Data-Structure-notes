# 计算

研究对象和研究目标

- 对象：规律、技巧
- 目标：高效、低耗

## 例子 1：绳索计算机

A 在一条直线上，如何经过点 A 做这条直线的垂直线。

_其实和勾股定理差不多？长度为 12 的绳索选其中的 3 段、4 段和 5 段，以 A 为中心，拉直的时候 A 点的垂直线就做出来了。_

## 例子 2：尺规计算机

任给出线段 AB，找到其两个点，将其三等分。

_初中解法，相似定理_

## 算法

计算=信息处理

借助某种工具，遵照一定规则，以明确而机械的形式进行。

计算模型=计算机=信息处理工具

算法，即特定计算模型下，旨在解决特定问题的指令序列。

- 输入
- 输出
- 正确性
- 确定性
- 可行性：每一基本操作都可实现，且在常数时间内完成。
- **有穷性**

## 算法：有穷性

实际上实现这一点非常困难。

考虑序列
```
Hailstone(n)=

{

{1}, n<=1;

{n} U Hailstone(n/2), n % 2 == 0;

{n} U Hailstone(3n+1), n % 2 == 1

}
```

根据这种规则写出的程序，不满足有穷性，因此不是算法。

**程序！=算法**
**死循环~有穷性**

## 好算法

正确：符合语法，能够编译、链接

健壮：能辨别不合法的输入并作适当处理

可读：结构化+准确命名+注释+...

**最重要的：效率**

- 速度尽可能快；
- 存储空间尽可能少

# 计算模型
## 性能测度
不同的DSA的性能有好坏优劣之别。

必须找到适当的方式来 **度量**。

## 问题规模
- 算法分析
  - 两个主要方面
    - 正确性
    - 成本：运行时间+所需存储空间

考察：T<sub>A</sub>(P) = 算法A求解实例P的计算成本
（*意义不大，因为可能出现问题的实例太多了*）

观察：问题实例的 **规模**，往往是决定计算成本的主要因素。

通常：规模接近，计算成本也接近；规模增加，计算成本亦上升。

## 最坏情况
### 特定算法 + 不同实例
令T<sub>A</sub>(n) = 用算法A求解某一问题规模为n的实例，所需的计算成本。

讨论特定算法A（及其对应的问题）时，简记作T(n)

这一定义仍然存在问题。

观察：同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。

## 理想模型
### 特定问题 + 不同算法
同一问题通常有多种算法，如何评判其优劣？
 
实验统计是最直接的算法，但是不足以准确反映算法的真正效率。
  1. 不同的算法，可能更适应于不同规模的输入
  2. 不同的算法，可能更适应于不同类型的输入
  3. 同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现
  4. 同一算法，可能实现并运行于不同的体系结构、操作系统

为给出 **客观** 的评判，需要抽象出一个 **理想** 的平台或模型
    1. 不再依赖于上述种种具体的因素
    2. 从而直接而准确地描述、测量并评价算法

## 图灵机
### Tape 
纸带被均匀地划分为单元格（cell），各注有某一字符，默认为‘#’
### Alphabet 
字符的种类有限
### Head 
总是对准Tape上的某一个cell。

每一次对准cell的时候，都可以读取或改写其中的字符。每经过一个节拍，可以转向左侧或右侧的临格。

### State
TM 总是处于有限种状态中的某一种。每经过一个节拍，可（按照**规则**）转向另一种状态。

### Transition Function : (q, c; d, L/R, p)
若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；转入p状态。

一旦转入特定的状态'h'，则停机。

## 图灵机实例
### TM : Increase
- 功能： **将二进制非负整数加一**
- 算法：全'1'的后缀翻转为全'0'，原最低为的'0'或'#'翻转为'1'

## RAM模型（Random Access Machine）
- 寄存器顺序编号，总数没有限制

- 每一基本操作仅需常数时间

- 与TM模型一样，RAM模型也是一般计算工具的简化和抽象。使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。

- 在这些模型中，算法的运行时间->算法需要执行的基本操作次数
- T(n) = 算法为求解规模为n的问题，所需执行的基本操作次数
- 优点：摆脱了不同机器的限制，更加客观。

## RAM实例

RAM : Floor
功能：向下取整的除法，0<=c, 0<d

算法：反复地从R[0] = 1 + c中减去R[1] = d。统计下溢之前，所做减法的次数x。

**图灵机、RAM等模型为度量算法性能提供了准确的尺度。**

# 大O记号
## 主流长远
### 渐进分析：大O记号
渐进分析：在问题规模足够大后，计算成本如何增长？

需要执行的基本操作次数：T(n) = ?
需占用的存储单元数：S(n) = ? 

### 大O记号（big-O notation）

T(n) = O(f(n)) 

iff $\exists$ c > 0，当n >> 2后，有T(n) < c * f(n)

与T(n)相比，f(n)更为简洁，但依然反映前者的增长趋势。

常系数可忽略：O(f(n)) = O(c * f(n))

低次项可忽略：O(n<sup>a</sup> + n<sup>b</sup>) = O(n<sup>a</sup>), a > b > 0

### 高效解
**常数（constant function）-> O(1)**

这类算法的效率最高。

如果一段代码不包含隐式或显式的循环，即不含由分支判断构成的代码体，则必然是顺序执行，也就是O(1)的复杂度。

**对数复杂度（对数多项式复杂度） -> O(log<sup>c</sup>n)。**

常底数无所谓

$\forall$ a, b > 0, log<sub>a</sub>n = log<sub>a</sub>b * log<sub>b</sub>n = $\bigodot$(log<sub>b</sub>n)

常次数幂无所谓

$\forall$ c > 0, logn<sup>c</sup> = c * logn = $\bigodot$(logn)

对数多项式（ploy-log function）

这类算法非常有效，复杂度无限接近于常数。
$\forall$ c > 0, logn = O(n<sup>c</sup>)

### 有效解
**O(n<sup>c</sup>)**

多项式复杂度

线性复杂度：所有O(n)类函数。

从O(n)到O(n<sup>2</sup>) : 编程习题主要覆盖的范围。

### 难解
指数复杂度（exponential function） ： T(n) = a <sup>n</sup>

这类算法的计算成本增长极快，但通常被认为不可忍受。

从O(n<sup>c</sup>)到O(2<sub>n</sub>)，是从**有效算法**到**无效算法**的分水岭。

很多问题的O(2<sup>n</sup>)算法往往显而易见，但是设计出O(n<sup>c</sup>)算法却极其不易，甚至有时注定只能是徒劳无功的。

### 2-Subset
【问题描述】

S包含n个正整数，$\sum$S=2m。S是否有子集T，满足$\sum$T = m？

**直觉算法：** 逐一枚举S的每一个子集，并统计其中元素的总和。

**定理：** |2<sup>S</sup> = 2<sup>|S|</sup> = 2<sup>n</sup>

定理：2-Subset is NP-complete

意即：就目前的计算模型而言， **不存在** 可在多项式时间内回答此问题的算法。就此意义而言，上述的直觉算法已经是最优算法。

### 增长速度
（是个图）

# 算法分析

## 算法分析
两个主要任务 = 正确性（不变性 * 单调性） + 复杂度

C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当。

复杂度分析的主要方法
- 迭代：级数求和
- 递归：递归跟踪 + 递推方程
- 猜测 + 验证

## 级数
算数级数：与末项平方同阶。

T(n) = 1 + 2 + ... + n = n(n + 1) / 2 = O(n<sup>2</sup>)

幂方级数：比幂次高出一阶。

例如：
T<sub>2</sub>(n) = 1<sup>2</sup> + 2<sup>2</sup> + ... + n<sup>2</sup> = O(n<sup>3</sup>)

推导公式：

$\sum_{i=0}^nk^{d}$ $\approx$ $\int_0^nx^{d+1}{dx}$ = ${{1} \over {d+1}}x^{d+1}|_0^n$ = ${{1}\over {d+1}}n^{d+1}$ = $O(n^{d+1})$

几何级数（a > 1）：与末项同阶。

收敛级数：

$\sum{{1} \over {n(n+1)}}$ = $O(1)$

$\sum{{1} \over {n^2}}$ = $O(1)$

${{{1} \over {3}}+{{1} \over {7}}+{{1} \over {8}}+{{1} \over {15}}+{{1} \over {24}}+...}$ = 1 = $O(1)$

在某种意义上，基本操作次数、存储单元数确实可以等效于分数。因此级数在算法分析中有意义。

存在另一种级数，可能未必收敛，但是长度有限。

例如：

h(n) = 1 + 1/2 + 1/3 + ... + 1/n = $\bigodot$(logn) 

log1+log2+log3+...+logn = log(n!) = $\bigodot$(nlogn)

## 循环
**（请把习题集上的练习题全部做会）**

## 实例：非极端元素+起泡排序

【问题描述】

给定整数子集S，|S| = n>=3。找出元素a$\in$max(S)且a$\neq$max(S)且a$\neq$min(S)

【算法】

从S中任取三个元素{x, y, z}。

//若S以数组形式给出，不妨取前三个

//由于S是集合，这三个元素必互异

确定并排除其中的最小、最大者

//不妨设x = max{x, y, z}, y = min{x, y, z}

输出剩下的元素z

## 封底估算
例子： 考察对全国人口普查数据的排序

# 迭代与递归
## 迭代与递归
## 减而治之
【Decrease-and-conquer】
为求解一个大规模的问题，可以
1. 将其划分为两个子问题：其一平凡，另一规模缩减
2. 分别求解子问题
3. 由子问题的解，得到原问题的解

## 递归跟踪
- 检查每个递归实例
  - 累计所需时间（调用语句本身，计入对应的子实例）

- 其总和即算法执行时间

- 应用范围：直观形象，仅适用于简明的递归模式

## 递推方程
- 间接抽象，更适用于复杂的递归模式

## 数组倒置
任给数组```A[0, n)```,将其前后颠倒。
统一接口：```void reverse(int* A, int lo, int hi);```

**递归版**
```
if(lo < hi)
{
  swap(A[lo], A[hi]);
  reverse(A, lo + 1, hi - 1);
}
else
  return ;
```

**迭代原始版**
```
if(lo < hi)
{
  swap(A[lo], A[hi]);
  lo++;
  hi--;
  goto next;
}
```

**迭代精简版**
```
while(lo < hi)
{
  swap(A[lo++], A[hi--]);
}
```

## 分而治之
**Divide-and-conquer**
为求解一个大规模的问题，可以
- 将其划分为若干（通常两个）子问题，规模大体相当
- 分别求解子问题
- 由子问题的解，得到原问题的解

## 数组求和：二分递归
