1. The same abstract data type may be implemented using multiple data structures. 同一个抽象数据类型可能用多种数据结构实现。
2. 一个初始为空的向量上依次执行：insert(0, 2), insert(1, 6), put(0, 1), remove(1), insert(0, 7) 后的结果是： **{7, 1}** 。
3. [以下代码是向量复制代码的一个变体且语义与其相同，空格处应填入的内容为：](https://qn-next.xuetangx.com/15730292038108.png)```--hi```。
4. 在一个初始最大容量为10的空向量上依次执行：insert(0, 2), insert(1, 6), put(0, 1), remove(1), insert(0, 7) 后的装填因子是：**20%**。
5. 是否可以将视频里向量扩容代码中的：
```for (int i = 0; i < _size; i++) _elem[i] = oldElem[i];```
替代为：```memcpy(_elem, oldElem, _size * sizeof(T));```
**否，因为后者能否达到目的与元素类型T有关。**
6. 采用每次追加固定内存空间的扩容策略，规模为n的向量插入元素的分摊时间复杂度为： **$\Theta(n)$**。
7. 分别采用每次追加固定内存空间和每次内存空间翻倍两种扩容策略，规模为n的向量插入元素的分摊时间复杂度分别为：**$\Theta(n)， \Theta(1)$**。
8. 分摊复杂度所考量的一串操作序列一定是真实可行的。平均复杂度依赖于对各操作出现概率的假设，而分摊复杂度则不是如此。加倍扩容策略中Θ(1)的结论是指分摊复杂度。
